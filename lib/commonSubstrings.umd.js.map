{"version":3,"file":"commonSubstrings.umd.js","sources":["../src/commonSubstrings.ts"],"sourcesContent":["/**\n * Created by Hanwen on 01.07.2014.\n * updated 2.0 by Hanwen on 03.02.2019.\n * updated 3.0 by Hanwen on 11.04.2020\n */\nimport {Node, Substring} from './types';\n\nexport default function getSubstrings(array: string[], {minLength, minOccurrence} = {\n\tminLength: 3,\n\tminOccurrence: 2,\n}): Substring[] {\n\tconst root = generateNewNode('');\n\tconst horizontalRoot = generateNewNode('');\n\tbuildTrie(array, root, horizontalRoot, minLength);\n\taccumulateVertically(root, minLength, minOccurrence);\n\taccumulateHorizontally(horizontalRoot, minOccurrence);\n\tconst resultArray: Substring[] = [];\n\tlisting(root, resultArray);\n\treturn resultArray;\n}\n\nfunction generateNewNode(label: string): Node {\n\treturn {\n\t\tsource: new Set<number>(),\n\t\tlisting: false,\n\t\tlabel,\n\t\thorizontal: new Map<string, Node>(),\n\t\tstructure: new Map<string, Node>()\n\t}\n}\n\nfunction buildTrie(array: string[], root: Node, horizontalRoot: Node, minLength: number): void {\n\tarray.forEach((word: string, originIndex: number) => {\n\t\tconst lastSuffixPointers: Node[] = [];\n\t\tfor (let i = 0; i <= word.length - minLength; i++) {\n\t\t\tlet pointer = root;\n\t\t\tconst suffix = word.substring(i);\n\t\t\tconst chars = suffix.split('');\n\n\t\t\tchars.reduce((currentNode, char, charIndexInSuffix) => {\n\t\t\t\tconst currentBranchLength = charIndexInSuffix + 1;\n\t\t\t\tconst label = word.substring(i, i + currentBranchLength);\n\t\t\t\tif (currentNode.structure.has(char)) {\n\t\t\t\t\tcurrentNode.structure.get(char)!.source.add(originIndex);\n\t\t\t\t} else {\n\t\t\t\t\tconst newNode = generateNewNode(label);\n\t\t\t\t\tnewNode.source.add(originIndex);\n\t\t\t\t\tcurrentNode.structure.set(char, newNode);\n\t\t\t\t}\n\n\t\t\t\tcurrentNode = currentNode.structure.get(char)!;\n\n\t\t\t\tif (currentBranchLength >= minLength) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tconst labelInLastSuffix = word.substring(i - 1, currentBranchLength + i);\n\t\t\t\t\t\tconst lastPointer = lastSuffixPointers.shift();\n\t\t\t\t\t\tcurrentNode.horizontal.set(labelInLastSuffix, lastPointer!);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentBranchLength > minLength) {\n\t\t\t\t\t\tlastSuffixPointers.push(currentNode)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if it is the last min length suffix of the whole word, then add it to root\n\t\t\t\t\t\thorizontalRoot.horizontal.set(label, currentNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn currentNode;\n\t\t\t}, pointer);\n\t\t}\n\t\tconsole.assert(lastSuffixPointers.length === 0, 'the last suffix list should be cleared');\n\t});\n}\n\nfunction accumulateVertically(node: Node, minLength: number, minOccurrences: number): Set<number> {\n\tlet childrenListedOccurrences = Array.from(node.structure.entries()).reduce((acc: Set<number>, [label, node]) => {\n\t\tconst childSources = accumulateVertically(node, minLength, minOccurrences);\n\t\tif (node.label.length <= minLength)\n\t\t\treturn acc;\n\n\t\treturn new Set([...acc, ...childSources]);\n\t}, new Set<number>());\n\n\tif (node.label.length < minLength) {\n\t\treturn childrenListedOccurrences;\n\t}\n\n\tconst remainedOccurrences = new Set(\n\t\t[...node.source].filter(x => !childrenListedOccurrences.has(x)));\n\tif (remainedOccurrences.size >= minOccurrences) {\n\t\tnode.listing = true;\n\t\treturn node.source;\n\t} else {\n\t\treturn childrenListedOccurrences;\n\t}\n}\n\nfunction accumulateHorizontally(node: Node, minOccurrences: number): Set<number> {\n\tlet childrenListedOccurrences = Array.from(node.horizontal.entries()).reduce((acc: Set<number>, [label, node]) => {\n\t\tconst childSources = accumulateHorizontally(node, minOccurrences);\n\t\treturn new Set([...acc, ...childSources]);\n\t}, new Set<number>());\n\n\tconst remainedOccurrences = new Set(\n\t\t[...node.source].filter(x => !childrenListedOccurrences.has(x)));\n\tif (remainedOccurrences.size >= minOccurrences) {\n\t\treturn node.source;\n\t} else {\n\t\tnode.listing = false;\n\t\treturn childrenListedOccurrences;\n\t}\n}\n\nfunction listing(node: Node, resultsSubstrings: Substring[]): void {\n\tArray.from(node.structure.entries()).forEach(([label, childNode]) => {\n\t\tlisting(childNode, resultsSubstrings);\n\n\t\tif (childNode.listing) {\n\t\t\tresultsSubstrings.push({\n\t\t\t\tsource: Array.from(childNode.source),\n\t\t\t\tname: childNode.label,\n\t\t\t\tweight: childNode.source.size * childNode.label.length\n\t\t\t})\n\t\t}\n\t})\n}\n"],"names":["generateNewNode","label","source","Set","listing","horizontal","Map","structure","array","minLength","minOccurrence","root","horizontalRoot","forEach","word","originIndex","lastSuffixPointers","pointer","substring","i","split","reduce","currentNode","char","charIndexInSuffix","currentBranchLength","has","get","add","newNode","set","labelInLastSuffix","lastPointer","shift","push","length","console","assert","buildTrie","accumulateVertically","node","minOccurrences","childrenListedOccurrences","Array","from","entries","acc","childSources","filter","x","size","accumulateHorizontally","resultArray","resultsSubstrings","childNode","name","weight"],"mappings":"+KAqBA,SAASA,EAAgBC,SACjB,CACNC,OAAQ,IAAIC,IACZC,SAAS,QACTH,EACAI,WAAY,IAAIC,IAChBC,UAAW,IAAID,qBApBqBE,oBAA8C,CACnFC,UAAW,EACXC,cAAe,wCAETC,EAAOX,EAAgB,IACvBY,EAAiBZ,EAAgB,KAmBxC,SAAmBQ,EAAiBG,EAAYC,EAAsBH,GACrED,EAAMK,iBAASC,EAAcC,WACtBC,EAA6B,qBAE9BC,EAAUN,EACCG,EAAKI,UAAUC,GACTC,MAAM,IAErBC,gBAAQC,EAAaC,EAAMC,OAC1BC,EAAsBD,EAAoB,EAC1CvB,EAAQa,EAAKI,UAAUC,EAAGA,EAAIM,MAChCH,EAAYf,UAAUmB,IAAIH,GAC7BD,EAAYf,UAAUoB,IAAIJ,GAAOrB,OAAO0B,IAAIb,OACtC,KACAc,EAAU7B,EAAgBC,GAChC4B,EAAQ3B,OAAO0B,IAAIb,GACnBO,EAAYf,UAAUuB,IAAIP,EAAMM,MAGjCP,EAAcA,EAAYf,UAAUoB,IAAIJ,GAEpCE,GAAuBhB,EAAW,IACjCU,EAAI,EAAG,KACJY,EAAoBjB,EAAKI,UAAUC,EAAI,EAAGM,EAAsBN,GAChEa,EAAchB,EAAmBiB,QACvCX,EAAYjB,WAAWyB,IAAIC,EAAmBC,GAG3CP,EAAsBhB,EACzBO,EAAmBkB,KAAKZ,GAGxBV,EAAeP,WAAWyB,IAAI7B,EAAOqB,UAGhCA,GACLL,IAjCKE,EAAI,EAAGA,GAAKL,EAAKqB,OAAS1B,EAAWU,SAmC9CiB,QAAQC,OAAqC,IAA9BrB,EAAmBmB,OAAc,4CAxDjDG,CAAU9B,EAAOG,EAAMC,EAAgBH,GA4DxC,SAAS8B,EAAqBC,EAAY/B,EAAmBgC,OACxDC,EAA4BC,MAAMC,KAAKJ,EAAKjC,UAAUsC,WAAWxB,gBAAQyB,gBACtEC,EAAeR,EAAqBC,EAAM/B,EAAWgC,UACvDD,EAAKvC,MAAMkC,QAAU1B,EACjBqC,EAED,IAAI3C,IAAQ2C,SAAQC,KACzB,IAAI5C,YAEHqC,EAAKvC,MAAMkC,OAAS1B,EAChBiC,EAGoB,IAAIvC,IAC/B,UAAIqC,EAAKtC,QAAQ8C,gBAAOC,UAAMP,EAA0BhB,IAAIuB,MACrCC,MAAQT,GAC/BD,EAAKpC,SAAU,EACRoC,EAAKtC,QAELwC,EA9ERH,CAAqB5B,EAAMF,EAAWC,GAkFvC,SAASyC,EAAuBX,EAAYC,OACvCC,EAA4BC,MAAMC,KAAKJ,EAAKnC,WAAWwC,WAAWxB,gBAAQyB,SACvEC,EAAeI,OAA6BV,UAC3C,IAAItC,IAAQ2C,SAAQC,KACzB,IAAI5C,YAEqB,IAAIA,IAC/B,UAAIqC,EAAKtC,QAAQ8C,gBAAOC,UAAMP,EAA0BhB,IAAIuB,MACrCC,MAAQT,EACxBD,EAAKtC,QAEZsC,EAAKpC,SAAU,EACRsC,GA7FRS,CAAuBvC,EAAgBF,OACjC0C,EAA2B,UAgGlC,SAAShD,EAAQoC,EAAYa,GAC5BV,MAAMC,KAAKJ,EAAKjC,UAAUsC,WAAWhC,+BACpCT,EAAQkD,EAAWD,GAEfC,EAAUlD,SACbiD,EAAkBnB,KAAK,CACtBhC,OAAQyC,MAAMC,KAAKU,EAAUpD,QAC7BqD,KAAMD,EAAUrD,MAChBuD,OAAQF,EAAUpD,OAAOgD,KAAOI,EAAUrD,MAAMkC,WAvGnD/B,CAAQO,EAAMyC,GACPA"}